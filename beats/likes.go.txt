package beats

import (
	"context"
	"log"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/julienschmidt/httprouter"
	"github.com/redis/go-redis/v9"
	"go.mongodb.org/mongo-driver/bson"

	"naevis/db"
	"naevis/models"
	"naevis/profile"
	"naevis/rdx"
	"naevis/utils"
)

func redisLikeKey(entityType, entityID string) string {
	return "like:count:" + entityType + ":" + entityID
}

func ToggleLike(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	ctx := context.TODO()
	entityType := ps.ByName("entitytype")
	entityID := ps.ByName("entityid")
	token := r.Header.Get("Authorization")

	claims, err := profile.ValidateJWT(token)
	if err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	filter := bson.M{
		"user_id":     claims.UserID,
		"entity_type": entityType,
		"entity_id":   entityID,
	}

	var existing models.Like
	err = db.LikesCollection.FindOne(ctx, filter).Decode(&existing)
	redisKey := redisLikeKey(entityType, entityID)

	if err == nil {
		// Already liked → Unlike
		_, _ = db.LikesCollection.DeleteOne(ctx, filter)
		_ = rdx.Conn.Decr(ctx, redisKey).Err()

		utils.RespondWithJSON(w, http.StatusOK, map[string]any{
			"liked": false,
		})
		return
	}

	// Not yet liked → Add like
	like := models.Like{
		UserID:     claims.UserID,
		EntityType: entityType,
		EntityID:   entityID,
		CreatedAt:  time.Now(),
	}

	_, err = db.LikesCollection.InsertOne(ctx, like)
	if err != nil {
		http.Error(w, "Failed to like", http.StatusInternalServerError)
		return
	}

	_ = rdx.Conn.Incr(ctx, redisKey).Err()

	utils.RespondWithJSON(w, http.StatusOK, map[string]any{
		"liked": true,
	})
}

// func GetLikeCount(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
// 	ctx := context.TODO()
// 	entityType := ps.ByName("entitytype")
// 	entityID := ps.ByName("entityid")
// 	redisKey := redisLikeKey(entityType, entityID)

// 	// Try Redis first
// 	count, err := rdx.Conn.Get(ctx, redisKey).Int64()
// 	if err == nil {
// 		utils.RespondWithJSON(w, http.StatusOK, map[string]int64{"count": count})
// 		return
// 	}

// 	// Fallback to MongoDB
// 	filter := bson.M{
// 		"entity_type": entityType,
// 		"entity_id":   entityID,
// 	}

// 	count, err = db.LikesCollection.CountDocuments(ctx, filter)
// 	if err != nil {
// 		http.Error(w, "Count failed", http.StatusInternalServerError)
// 		return
// 	}

// 	// Cache it in Redis for next time
// 	_ = rdx.Conn.Set(ctx, redisKey, count, 10*time.Minute).Err()

//		utils.RespondWithJSON(w, http.StatusOK, map[string]int64{"count": count})
//	}
func GetLikeCount(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	entityType := ps.ByName("entitytype")
	entityID := ps.ByName("entityid")
	redisKey := redisLikeKey(entityType, entityID)

	// Try Redis first
	countStr, err := rdx.Conn.Get(ctx, redisKey).Result()
	if err == nil {
		if count, parseErr := strconv.ParseInt(countStr, 10, 64); parseErr == nil {
			utils.RespondWithJSON(w, http.StatusOK, map[string]int64{"count": count})
			return
		}
	}
	if err != nil && err != redis.Nil {
		log.Printf("Redis Get error: %v", err)
	}

	// Fallback to MongoDB
	filter := bson.M{"entity_type": entityType, "entity_id": entityID}
	count, err := db.LikesCollection.CountDocuments(ctx, filter)
	if err != nil {
		http.Error(w, "Count failed", http.StatusInternalServerError)
		return
	}

	// Cache in Redis for future requests
	if err := rdx.Conn.Set(ctx, redisKey, count, 10*time.Minute).Err(); err != nil {
		log.Printf("Redis Set error: %v", err)
	}

	utils.RespondWithJSON(w, http.StatusOK, map[string]int64{"count": count})
}

func SyncLikeCountsToMongo() {
	ctx := context.TODO()
	keys, _ := rdx.Conn.Keys(ctx, "like:count:*").Result()

	for _, key := range keys {
		count, err := rdx.Conn.Get(ctx, key).Int64()
		if err != nil {
			continue
		}

		parts := strings.Split(key, ":")
		if len(parts) != 4 {
			continue
		}
		entityType, entityID := parts[2], parts[3]
		_ = entityType
		// Update to your own metadata store
		_, _ = db.PostsCollection.UpdateOne(ctx,
			bson.M{"_id": entityID},
			bson.M{"$set": bson.M{"like_count": count}},
		)
	}
}

// package beats

// import (
// 	"context"
// 	"net/http"
// 	"time"

// 	"github.com/julienschmidt/httprouter"
// 	"go.mongodb.org/mongo-driver/bson"

// 	"naevis/db"
// 	"naevis/models"
// 	"naevis/profile"
// 	"naevis/utils"
// )

// func ToggleLike(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
// 	entityType := ps.ByName("entitytype")
// 	entityID := ps.ByName("entityid")

// 	token := r.Header.Get("Authorization")
// 	claims, err := profile.ValidateJWT(token)
// 	if err != nil {
// 		http.Error(w, "Unauthorized", http.StatusUnauthorized)
// 		return
// 	}

// 	filter := bson.M{
// 		"user_id":     claims.UserID,
// 		"entity_type": entityType,
// 		"entity_id":   entityID,
// 	}

// 	// Check if like already exists
// 	var existing models.Like
// 	err = db.LikesCollection.FindOne(context.TODO(), filter).Decode(&existing)
// 	if err == nil {
// 		// Like exists → remove it (unlike)
// 		_, _ = db.LikesCollection.DeleteOne(context.TODO(), filter)
// 		utils.RespondWithJSON(w, http.StatusOK, map[string]interface{}{
// 			"liked": false,
// 		})
// 		return
// 	}

// 	// Not liked → add like
// 	like := models.Like{
// 		UserID:     claims.UserID,
// 		EntityType: entityType,
// 		EntityID:   entityID,
// 		CreatedAt:  time.Now(),
// 	}
// 	_, err = db.LikesCollection.InsertOne(context.TODO(), like)
// 	if err != nil {
// 		http.Error(w, "Failed to like", http.StatusInternalServerError)
// 		return
// 	}

// 	utils.RespondWithJSON(w, http.StatusOK, map[string]interface{}{
// 		"liked": true,
// 	})
// }

// func GetLikeCount(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
// 	entityType := ps.ByName("entitytype")
// 	entityID := ps.ByName("entityid")

// 	filter := bson.M{
// 		"entity_type": entityType,
// 		"entity_id":   entityID,
// 	}

// 	count, err := db.LikesCollection.CountDocuments(context.TODO(), filter)
// 	if err != nil {
// 		http.Error(w, "Count failed", http.StatusInternalServerError)
// 		return
// 	}

// 	utils.RespondWithJSON(w, http.StatusOK, map[string]int64{
// 		"count": count,
// 	})
// }

// /*
// // MongoDB Index (once)
// indexModel := mongo.IndexModel{
// 	Keys: bson.M{"user_id": 1, "entity_type": 1, "entity_id": 1},
// 	Options: options.Index().SetUnique(true),
// }
// _, err := db.LikesCollection.Indexes().CreateOne(context.TODO(), indexModel)
// if err != nil {
// 	log.Fatalf("Failed to create like index: %v", err)
// }

// */
